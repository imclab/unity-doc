! リジッドボディ / Rigidbody

$$Rigidbody$$ により、 $$GameObject$$ が物理特性の制御下で動作するようになります。 リジッドボディは、力やトルクを受け、現実的な方向にオブジェクトを動かすことができます。  GameObject は、重力の影響を影響を受けるリジッドボディを含めるか、スクリプティングを通じて加えた力の下で動作するか、NVIDIA PhysX 物理特性エンジンを通じて、その他のオブジェクトと相互作用する必要があります。

Attach:Inspector-Rigidbody.png\\
「リジッドボディにより、GameObject は物理的影響の下で動作できます」


!! プロパティ

||PROPS
||``Mass`` ||オブジェクトの質量 (単位 : kg)。 質量は、他のリジッドボディのおよそ 100 倍 以上にすべきではありません。 ||
||``Drag`` ||力により動く際に、オブジェクトに影響する空気抵抗の量。 0 の場合、空気抵抗が 0 で、無限の場合、オブジェクトは直ちに動きを止めます。 ||
||``Angular Drag`` ||トルクにより回転する際に、オブジェクトに影響する空気抵抗の量。 0 の場合、空気抵抗なし。このパラメータの値を無限 (infinity) に設定するだけでは、オブジェクトの回転を直ちにを止められないことに留意して下さい。 ||
||``Use Gravity`` ||有効にすると、オブジェクトは重力の影響を受けます。|| ||
||``Is Kinematic`` ||有効にすると、オブジェクトは物理特性エンジンによって駆動されませんが、その $$Transform$$ によってのみ操作できます。 これは、プラットフォームを移したい場合や、$$HingeJoint$$ を追加したリジッドボディをアニメート化したい場合に便利です。 ||
||``Interpolate`` || Rigidbody の動きがぎこちないとき、次のオプションを試して下さい。||
||>>>``None`` ||補間を適用しない。||
||>>>``Interpolate`` ||前フレームの Transform にもとづいて Transform のスムージング。||
||>>>``Extrapolate`` ||次フレームの Transform 予測にもとづいて Transform のスムージング。|| 
||``Collision Detection`` || 高速で動くオブジェクトが、衝突を検知せずにすり抜けることを防止するために使用します。 ||
||>>>``Discrete`` ||シーンの全 Collider に対してDiscrete (不連続) な衝突検知を行ないます(デフォルト)。||
||>>>``Continuous`` ||動的な コライダ （リジッドボディあり） にはDiscrete （不連続） な 衝突、静的なメッシュコライダ （リジッドボディなし） には Continuous （連続）な衝突を適用します。Continuous Dynamic を適用した リジッドボディ に対する衝突は、Continuous な衝突検知をします。これはContinuous Dynamic を適用したオブジェクトの衝突相手として使用します。（物理演算のパフォーマンスに大きく影響するため、高速なオブジェクトの衝突で問題が出ない場合はDiscrete のままにして下さい。）||
||>>>``Continuous Dynamic`` ||Continuous および Continuous Dynamic 衝突を適用したオブジェクトに対して、Continuous な衝突検知を行ないます。 静的なメッシュコライダ （リジッドボディ なし） にも Continuous な 衝突 を適用します。その他の コライダ については Discrete な衝突検知を行なう。高速で動くオブジェクトに使用します。||
||``Constraints`` ||リジッドボディの動きに関する制限:-||
||>>>``Freeze Position``||ワールド座標系の X、Y、Z 軸で移動するリジッドボディを選択的に停止します。||
||>>>``Freeze Rotation``||ワールド座標系の X、Y、Z 軸で回転するリジッドボディを選択的に停止します。||

!! 詳細

$$Rigidbody$$ により、GameObject が物理特性エンジンの制御下で動作するようになります。  これにより、現実的な衝突、多様な種類のジョイント、その他のクールな動作へのゲートウェイが開きます。  リジッドボディに力を加えることで、GameObject を操作することによって、 $$Component$$ を直接調整した場合とは違うルック & フィールを作成します。  一般に、リジッドボディと同じ GameObject のトランスフォームのどちらか一方だけを操作しないでください。

トランスフォームの操作とリジッドボディ間の最大の差は、力を使用するかしないかです。  リジッドボディは、力やトルクを受けることができますが、トランスフォームはできません。  トランスフォームは移動や回転はできますが、物理特性の使用とは異なります。 自分で試した場合は、その顕著な差に気づくでしょう。  リジッドボディに力/トルクを加えると、実際にオブジェクトの位置やトランスフォーム コンポーネントの回転を変更します。  このため、どちら一方だけを使用する必要があります。  物理特性使用中にトランスフォームを変更すると、衝突やその他の計算に問題が生じる場合があります。

リジッドボディは、物理特性エンジンに影響を受ける前に、GameObject に明示的に追加する必要があります。  メニューバーで「Components->Physics->Rigidbody」から選択したオブジェクトにリジッドボディを追加できます。 オブジェクトで物理特性の準備ができました。重力下に置かれ、スクリプティングを介して、力を受けることができますが、 $$Collider$$ またはジョイントを追加して、正確に希望通りに動作させる必要があります。


!!! 親子関係

オブジェクトが物理特性の制御下にある場合、トランスフォームの親が移動する方法から半分独立して移動します。 親を移動すると、リジッドボディの子をそれに沿って引っ張ります。 しかし、リジッドボディは重力および衝突イベントへの対応により、落下していきます。


!!! スクリプティング

リジッドボディをコントロールするため、最初にスクリプトを使用して、力またはトルクを追加します。 「[[ScriptRef:Rigidbody.AddForce.html|AddForce()]] 」 と「[[ScriptRef:Rigidbody.AddTorque.html|AddTorque()]] 」をオブジェクトのリジッドボディで呼び出すことでこれを行います。  物理特性を使用する際は、オブジェクトのトランスフォームを直接買えないようにしてください。


!!! アニメーション

一部の状況で、主にラグドール効果を作成する場合に、アニメーションと物理特性間でオブジェクトのコントロールを切り替える必要があります。 このため、リジッドボディには、「[[ScriptRef:Rigidbody-isKinematic.html|isKinematic]] 」と付けることができます。 リジッドボディに「isKinematic」と付いている場合、衝突や力、physX のその他の部分の影響を受けません。 This means that you will have to control the object by manipulating the [[class-Transform|Transform]] コンポーネントを直接操作することで、オブジェクトをコントロールする必要があるということです。  キネマティック リジッドボディはその他のオブジェクトに影響しますが、これら自体は物理特性の影響を受けません。 例えば、キネマティック オブジェクトに追加されるジョイントは、そこに追加されたその他のリジッドボディを制約し、キネマティック リジッドボディは衝突を通じて、その他のリジッドボディに影響します。


!!! コライダ

コライダは、衝突を発生させるために、リジッドボディと共に追加する必要のある別の種類のコンポーネントです。  2 つのリジッドボディが互いに衝突する場合、物理特性エンジンは、両方のオブジェクトもコライダを追加するまで、衝突を計算しません。  コライダのないリジッドボディは、物理特性シミュレーション中に互いを簡単に通過します。

Attach:RigidbodyandCollider.png\\
「コライダはリジッドボディの物理特性の境界を定義します」

「Component->Physics」メニューでコライダを追加します。  詳細については、個々のコライダのコンポーネント リファレンス ページを参照してください。
*[[class-BoxCollider|Box Collider]] - キューブのプリミティブの形状
*[[class-SphereCollider|Sphere Collider]] - 球体のプリミティブの形状
*[[class-CapsuleCollider|Capsule Collider]] - カプセルのプリミティブの形状
*[[class-MeshCollider|Mesh Collider]] - オブジェクトのメッシュからコライダを作成し、別のメッシュ コライダとは衝突できません
*[[class-WheelCollider|Wheel Collider]] - 車両またはその他の移動する乗り物の作成用


!!! 複合コライダ

(:include comp-ColliderCompound:)

!!! 連続衝突検知 / Continuous Collision Detection

連続衝突検知は、高速移動するコライダが互いにすり抜けないようにする機能です。 これは、通常の(「Discrete」) 衝突検知使用時、オブジェクトが 1 つのフレームでコライダの片側にあり、次のフレームでコライダを通過している場合に発生することがあります。 これを解決するには、高速移動するオブジェクトのリジッドボディで連続衝突検知を有効にできます。 衝突検知モードを「Continuous」に切り替え、リジッドボディがスタティックな (つまり、非リジッドボディ) メッシュコライダ を通過させないようにします。 衝突検知モードを「Continuous Dynamic」に切り替え、リジッドボディが、衝突検知モードを「Continuous」または「Continuous Dynamic」に設定したその他のサポートされているリジッドボディを通過させないようにします。 
連続衝突検知は、Box、Sphere および Capsule の コライダ でサポートされています。連続衝突検知は、オブジェクトですり抜けが発生してしまう場合に衝突をキャッチするためのセーフティネットが意図する用途ですが、物理的に正確な衝突結果が得られるわけではないため、高速に動くオブジェクトで問題がある場合は、TimeMangerインスペクタにある固定 Time step 変数を減らしてシミュレーションをより厳密に行うことが出来ます。

!! 正しいサイズの使用

GameObject のメッシュのサイズは、リジッドボディの質量よりもはるかに重要です。  リジッドボディが期待通りに動作しなていない場合、ゆっくり移動するか、浮くか、正しく衝突しません。  Unity のデフォルトの単位スケールは、1 単位 = 1 メートルなので、インポートされたメッシュのスケールは維持され、物理特性計算に適用されます。  例えば、倒壊しかけている高層ビルは、積み木で作った塔とはかなり違う形で崩れるため、正確にスケールするには、サイズの異なるオブジェクトをモデル化する必要があります。

人間をモデリングしている場合、Unity では、その人間の身長は約 2メートルになります。 オブジェクトが正しいサイズかどうかを確認するには、デフォルトのキューブと比較します。 ^^GameObject->Create Other->Cube^^ を使用して、キューブを新規作成します。 キューブの高さは、ちょうど 1 メートルになるため、作成している人間は 2 倍の身長になります。

メッシュ自体を調整できない場合、$$Project View$$ で選択し、メニューバーから ^^Assets->Import Settings...^^ を選択することで、特定のメッシュ　アセットの均一なスケールを変更できます。  ここでは、スケールを変更し、メッシュを再インポートできます。

ゲームで、GameObject を異なるスケールでインスタンス化する必要がある場合、トランスフォームのスケール軸の値を調整しても大丈夫です。  欠点は、物理特性シミュレーションは、オブジェクトのインスタンス化時に更に多くの作業をする必要があり、ゲーム内でパフォーマンスの低下を引き起こす可能性があります。  これは大きな損失ではありませんが、他の 2 つのオプションでスケールを仕上げることほど効率的ではありません。  不均一なスケールだと、パレンディング使用時に望まぬ動作を生じる場合があります。  このため、モデリング アプリケーションで正しいスケールでオブジェクトを作成するのが常に最適です。


!! ヒント
* 2 つのリジッドボディの相対的な「Mass」は、リジッドボディが互いに衝突する際に、どのように反応するかを決定します。
* 1 つのリジッドボディの「Mass」を他方より大きくしても、自由落下での落下速度は上がりません。 これを行うには、「Drag」を使用します。
* 「Drag」値が低いと、オブジェクトが重く見えるようになります。 この値が高いと、軽く見えます。 「Drag」の通常の値は、.001 (金属の塊) と 10 (羽) の間です。
* オブジェクトのトランスフォーム コンポーネントを直接操作しているが、物理特性が必要な場合、リジッドボディを追加し、キネマティックにします。
* トランスフォーム コンポーネントを通じて、GameObject を移動させているが、衝突/トリガー メッセージを受信したい場合は、リジッドボディを移動しているオブジェクトに追加する必要があります。
* Angular Drag の値を無限 (infinity) に設定するだけでは、オブジェクトの回転を直ちにを止められません。

